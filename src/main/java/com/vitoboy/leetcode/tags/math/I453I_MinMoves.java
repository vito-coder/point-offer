package com.vitoboy.leetcode.tags.math;

/**
 * 
 * 给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。 
 *
 *  示例：
 * 输入： [1,2,3]
 * 输出： 3
 * 解释：
 * 只需要3次操作（注意每次操作会增加两个元素的值）：
 * [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
 *  
 *  Related Topics 数组 数学 
 *  👍 234 👎 0
 * 
 * 
 * @author vito
 * @version 1.0
 * @date 2021/7/5
 */
public class I453I_MinMoves {
    public static void main(String[] args) {

    }

    /**
     * [1,2,3,4]->[2,3,4,4]->[3,4,5,4]->[4,5,5,5]->[5,6,6,5]->[6,7,6,6]->[7,7,7,7]
     *
     * [2,3,4,4]-> 5
     *
     * [1,9,10]->[2,10,10]->[3,11,10]->[4,11,11]->[5,11,12]->[6,12,12]->[7,13,12]->[8,13,13]->[9,14,13]->[10,14,14]
     *      ->[11,15,14]->[12,15,15]->[13,16,15]->[14,16,16]->[15,17,16]->[17,17,17]
     *
     * [1,10,10]->[2..]->[3,11,11]->[4..]->[5.12,12]->[6..]->[7,13,13]->[8..]->[9,14,14]->[10..]->[11,15,15]->[12..]->[13,16,16]
     *      ->[14..]->[15,17,17]->[16..]->[17,18,18]->[18..]->[19,19,19]
     *
     *
     * 参考官方题解:
     *
     * 将除了一个元素之外的全部元素+1，等价于将该元素-1，因为我们只对元素的相对大小感兴趣。因此，该问题简化为需要进行的减法次数。
     *
     * 显然，我们只需要将所有的数都减到最小的数即可。为了找到答案，我们不需要真的操作这些元素。只需要 moves=\sum_{i=0}^{n-1} a[i] - min(a)*nmoves=∑
     * i=0
     * n−1
     * ​
     *  a[i]−min(a)∗n 即可，其中 n 为数组的数量。
     *
     * 作者：LeetCode
     * 链接：https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/solution/zui-xiao-yi-dong-ci-shu-shi-shu-zu-yuan-su-xiang-d/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     *
     * 				解答成功:
     * 				执行耗时:2 ms,击败了85.32% 的Java用户
     * 				内存消耗:38.9 MB,击败了39.53% 的Java用户
     *
     * 时间复杂度: O(N)
     * 空间复杂度: O(1)
     *
     * @param nums
     * @return
     */
    public int minMoves(int[] nums) {
        int move = 0, min = Integer.MAX_VALUE;
        for (int num : nums) {
            min = Math.min(min, num);
        }
        for (int num : nums) {
            move += (num-min);
        }

        return move;
    }

}
